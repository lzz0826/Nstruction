從快到慢列出，並說明它們之間的差距：

O(1) - 常數時間複雜度
描述：無論輸入大小如何，演算法的運行時間都固定不變。
例子：訪問數組中的某個元素。

O(log N) - 對數時間複雜度
描述：隨著輸入大小 N 增加，運行時間按對數比例增加。
例子：二分查找。

O(N) - 線性時間複雜度
描述：運行時間與輸入大小 N 成正比。
例子：遍歷一個長度為 N 的數組。

O(N log N) - 線性對數時間複雜度
描述：運行時間比線性增長得更快，但比二次增長慢。
例子：快速排序、合併排序。

O(N^2) - 二次時間複雜度
描述：運行時間與輸入大小的平方成正比。
例子：冒泡排序、選擇排序。

O(N^3) - 三次時間複雜度
描述：運行時間與輸入大小的立方成正比。
例子：三重嵌套的迴圈，例如矩陣乘法的簡單實現。

O(2^N) - 指數時間複雜度
描述：運行時間隨輸入大小呈指數級增長。
例子：解決旅行推銷員問題的暴力法、一些遞歸算法。

O(N!) - 階乘時間複雜度
描述：運行時間與輸入大小的階乘成正比。
例子：解決旅行推銷員問題的暴力法、排列生成算法。

這些時間複雜度級別反映了演算法效率上的巨大差異：
O(1) 是最優的，適用於那些只需要執行固定操作次數的情況。
O(log N) 是非常高效的，適用於需要減少搜索空間的演算法。
O(N) 是線性增長，隨輸入規模直接增長，效率適中。
O(N log N) 比線性增長稍快，但仍然被認為是高效的，特別適用於排序演算法。
O(N^2) 和更高次的多項式時間複雜度適用於一些基本算法，但在大規模數據上可能表現不佳。
O(2^N) 和 O(N!) 是非常低效的，隨著輸入規模增加，運行時間迅速變得不可接受，通常只在非常小的數據集上使用。