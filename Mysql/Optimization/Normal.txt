


**注意 在使用sys或performance_schema information_schema 會消耗大量資源 可能導致業務請求被阻塞)

-------索引相關-------

顯示最近一條 SQL 语句执行后产生的所有警告、错误和通知信息
SHOW WARNINGS;

查看 MySQL 查询优化器的跟踪信息
SELECT * FROM information_schema.optimizer_trace;


查詢冗餘索引
select * from sys.schema_redundant_indexes ;

查詢未使用過的索引
select * from sys.schema_unused_indexes ;

查詢索引的使用狀況
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted
from sys.schema_index_statistics where table_schema = 'dbname'

-------表相關-------

查詢表的訪問量
select table_schema,table_name,sum(io_read_requests + io_write_requests) as io
from sys.schema_table_statistics
group by table_schema,table_name
order by io desc ;

查詢佔用bufferpool較多的表
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10;

查看表的全表掃描狀況
select * from sys.statements_with_full_table_scans where db = 'dbname'

-------語句相關-------

監控SQL執行的頻率
select db,exec_count,query from sys.statement_analysis
order by exec_count desc ;

監控使用了排序的SQL
SELECT db, exec_count, first_seen, last_seen, query
FROM sys.statements_with_sorting
LIMIT 1;

監控使用了臨時表或磁盤臨時表的SQL
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables > 0
order by (tmp_tables+tmp_disk_tables) desc ;

-------IO相關-------

查看消耗磁盤IO的文件
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;

-------Innodb相關-------

行鎖阻塞情況
select * from sys.innodb_lock_waits


----------------------------------------------------------------------------------------

物理查詢優化 : 通過 索引 和 表連接方式 等技術來進行優化 重點掌握索引的使用
邏輯查詢優化 : 通過 SQL 等價變換 提升查詢效率 換一種查詢寫法執行效率可能更高

索引優化：
    索引失效：確保查詢中使用的條件列都有相應的索引，並避免在索引列上進行運算或函數操作，以確保索引的有效性。
    索引建立：對於經常使用的查詢條件，建立合適的索引可以提高查詢性能。

SQL 查詢優化：
    關聯查詢過多 JOIN：
        考慮查詢中是否有不必要的 JOIN 操作，或者是否可以使用其他方式簡化查詢。
        小表驅動大表
        Simple Nested-Loop join :  在大表(數據量大的) . 被驅動表 加上索引
        Block Nested-Loop Join:  調整 join_buffer_size 大小
    子查詢優化：
        盡量不要使用子查詢 可以改成 JOIN
        盡量不要使用NOT IN 或者 NOT EXISTS 用 LEFT JOIN xxx ON xx WHERE xx IS NULL 代替
    ORDER BY 優化 : 
        盡量使用 index 如不行對 FileSort條優
        WHERE 和 ORDER BY 後面相同使用單索引 如果不同用聯合索引(先WHERE 後 ORDER BY)
        聯合索引的升序降序必須一致：在使用聯合索引時，所有字段的排序方向（升序或降序）必須一致，否則索引會失效。
        搜尋字段在 ORDER BY 範圍內：為了使索引在排序時有效，ORDER BY 子句中的字段應包含在索引中，且索引應覆蓋查詢所需的所有字段（覆蓋索引）。
        使用 LIMIT 可以增加使用索引的機會，特別是在數據量較大的情況下。
        當範圍條件 和 group by或order by 的字段出現二選一時 優先觀察條件字段的過濾字段 如過濾的數據足夠多 需要排序的數據不多 優先把索引放在範圍字段上 反之亦然
        ORDER BY 使用 SELECT * 是大忌 最好只Query需要的字段
        條優FileSort:
            SHOW VARIABLES LIKE '%sort_buffer_size%';
            SHOW VARIABLES LIKE '%max_length_for_sort_data%';
    GROUP BY 優化:
        索引原則幾乎跟ORDER BY 一致 先排序在分組 遵照索引建的最佳左前綴法則
        無法使用索引列時 增大 max_length_fro_sort_data 和 sort_buffer_size參數設置
        where效率高於having 能寫在where限定的條件就不要寫在having中
        減少使用order by 或將排序放到程序端執行 Order by group by distinct 這些語句較耗費CPU
        Order by group by distinct 這些查詢語句 where條件過濾出來的結果保持在1000行內 否則SQL會很慢
    LIMIT 優化:
        僅返回 2000000 - 2000010 的紀錄其他丟棄 代價非常大
           EXPLAIN SELECT * FROM student LIMIT 2000000,10;
        在索引上完成排序分頁操作 最後根據主建關聯回原表查詢所需要的其他內容(盡量往聚簇索引靠)
           EXPLAIN SELECT * FROM student t, (SELECT id FROM student ORDER BY id LIMIT 2000000,10) a
           WHERE t.id = a.id
        適用於主建字增的表 把LIMIT查詢轉換成某個位子的查詢
           EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;

MySQL 參數調優：
    服務器參數調優：檢查和調整 MySQL 服務器的配置參數，如緩衝池大小、線程數等，以確保服務器能夠有效地使用系統資源。
    my.cnf 調整：通過修改 MySQL 配置文件（如 my.cnf）來調整系統參數，以滿足具體的性能需求和硬件配置。

數據量優化：
    數據過多：對於數據量過大的情況，可以考慮進行數據分區、分表或者分庫來提高查詢效率和管理成本。

磁盤和存儲優化：
    使用 SSD：將 MySQL 數據庫和日誌文件存儲在 SSD 上，可以顯著提高 IO 性能。
    RAID 配置：根據寫入和讀取需求，選擇合適的 RAID 等級配置。

查詢緩存和結果緩存：
    查詢緩存：對於經常查詢的數據，可以考慮使用緩存技術，如 Memcached 或 Redis，以減輕數據庫負載。
    結果緩存：將經常使用的查詢結果緩存到應用程序層，以減少對數據庫的查詢次數。

查詢重構和優化：
    查詢重構：對於複雜的查詢，可以重新設計查詢結構，將其分解為更簡單和高效的子查詢。
    查詢優化：使用 EXPLAIN 等工具來分析查詢計劃，並進行適當的索引和統計信息調整。

緩衝區和快取優化：
    MySQL 緩衝池：調整 MySQL 的緩衝池大小以提高內存利用率和查詢性能。
    應用程序快取：將經常使用的數據和查詢結果快取到應用程序層，以減少對數據庫的訪問。